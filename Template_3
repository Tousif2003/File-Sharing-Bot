<!-- âœ… Font Awesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

<!-- âœ… Plyr CSS & JS -->
<link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css">
<script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>

<!-- âœ… HLS & DASH (optional adaptive) -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script src="https://cdn.dashjs.org/latest/dash.all.min.js"></script>

<style>
  /* user's original small focus tweak */
  .plyr__control:focus {
    outline: none;
    -webkit-tap-highlight-color: transparent;
  }

  /* --- sane stacking for Plyr controls (safe defaults) --- */
  .plyr__controls {
    position: relative;
    z-index: 2 !important;            /* modest z-index so controls don't cover page elements */
    pointer-events: auto !important;
  }

  /* keep big play overlay visually on top of video but not covering controls */
  .plyr__play-large {
    z-index: 4 !important;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    pointer-events: auto !important;
  }

  /* slightly reduce overlay on very small screens */
  @media (max-width: 640px) {
    .plyr__play-large { transform: translate(-50%, -60%) scale(0.95); }
  }

  /* landscape custom button style (single class) */
  .landscape-btn {
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:2px;
    padding:5px 8px;
    border-radius:8px;
    background: transparent;
    color: #fff;
    margin-left:6px;
    border: none;
    cursor: pointer;
  }

  /* page helper classes (won't conflict if your page has its own styles) */
  .req-player-wrap { width:100%; max-width:980px; }
  .req-player-video { width:100%; border-radius:10px; display:block; }

  /* optional: make sure custom appended buttons don't inherit undesirable styles */
  .plyr__controls .landscape-btn { font: inherit; }
</style>

<script>
document.addEventListener('DOMContentLoaded', () => {
  /************************************************************************
   * Integrated player block
   * - This block assumes your page already has a <video id="player"> element.
   * - It preserves the full original advanced logic (prefetch, MSE, sync)
   *   and inserts defensive fixes:
   *     â€¢ Plyr init guard (prevents duplicate initialization)
   *     â€¢ sane CSS stacking (controls/play-large)
   *     â€¢ idempotent manual play/pause + single landscape append
   ************************************************************************/

  // ðŸŽ¬ Grab the video element that you already have on the page
const videoEl = document.querySelector('#player');
if (!videoEl) {
  console.warn('req-player: #player element not found on page â€” player script aborted.');
  return;
}

// âš™ï¸ Defensive attributes (ensure expected playback behavior)
try {
  // preload="auto" ensures browser starts buffering immediately
  videoEl.setAttribute('preload', videoEl.getAttribute('preload') || 'auto');
  videoEl.setAttribute('playsinline', '');
  videoEl.setAttribute('crossorigin', 'anonymous');
} catch (e) {
  console.warn('req-player: failed to apply safe video attributes', e);
}

// ðŸŽ›ï¸ Controls limited as requested (keeps UI minimal)
const CONTROLS = [
  'play-large', 'rewind', 'play', 'fast-forward',
  'progress', 'current-time', 'duration'
];

/******************************************************
 * ðŸ§¹ Plyr init guard: destroy any previous instance so we
 * don't end up with duplicated controls or event handlers
 ******************************************************/
if (window.__reqPlyrInstance) {
  try { window.__reqPlyrInstance.destroy(); } catch (e) { /* ignore */ }
  window.__reqPlyrInstance = null;
}

// ðŸš€ Initialize Plyr instance
window.__reqPlyrInstance = new Plyr(videoEl, { controls: CONTROLS });
const player = window.__reqPlyrInstance;

// âœ… Force buffering kick-start (fixes 0.0s stuck / no playback issue)
if (videoEl && videoEl.readyState === 0) {
  try {
    videoEl.load();                 // Force reload of metadata + data
    const playPromise = videoEl.play();
    if (playPromise !== undefined) {
      playPromise.catch(() => {
        console.warn('req-player: autoplay blocked, waiting for user gesture');
      });
    }
  } catch (err) {
    console.warn('req-player: buffering kick-start failed', err);
  }
}

  /*******************************
   * ============================
   * âœ… Manual Play/Pause Button Fix (idempotent)
   * Inserted into player.on('ready') with landscape append guard
   * ============================
   *******************************/
  player.on('ready', () => {
    try {
      const controls = player.elements && player.elements.controls;
      if (!controls) return;

      // -------------------------
      // Manual Play/Pause Button Fix (idempotent)
      // -------------------------
      const smallPlaySel = '.plyr__control[data-plyr="play"], .plyr__control--play';
      const smallPlayBtn = controls.querySelector(smallPlaySel);
      if (smallPlayBtn && !smallPlayBtn._manualPlayBound) {
        smallPlayBtn._manualPlayBound = true;
        const handler = async (e) => {
          try { if (e && e.preventDefault) e.preventDefault(); } catch(_) {}
          try {
            // prefer Plyr API: keep internal state correct
            if (player && typeof player.play === 'function' && typeof player.pause === 'function') {
              if (player.playing) await player.pause();
              else await player.play();
              return;
            }
          } catch(err) {
            console.warn('Plyr API toggle error (fallback to native):', err);
          }
          // fallback to native element
          try {
            if (videoEl.paused) await videoEl.play();
            else videoEl.pause();
          } catch(err) { console.warn('Native play/pause failed:', err); }
        };
        smallPlayBtn.addEventListener('click', handler, { passive: false });
        smallPlayBtn.addEventListener('touchstart', handler, { passive: false });
      }

      // -------------------------
      // Append Landscape button only if not already appended
      // -------------------------
      if (typeof createLandscapeButton === 'function') {
        if (!controls.querySelector('.landscape-btn')) {
          const landscapeBtn = createLandscapeButton();
          landscapeBtn.classList.add('landscape-btn');
          controls.appendChild(landscapeBtn);
        }
      }

      // Defensive: ensure controls container styling does not break layout
      try {
        controls.style.pointerEvents = 'auto';
        if (!controls.style.zIndex) controls.style.zIndex = '2';
      } catch(e){}
    } catch (e) {
      console.warn('Play button patch failed', e);
    }
  });

  /*******************************
   * AudioContext + basic pipeline
   *******************************/
  let audioContext = null;
  let gainNode = null;
  function setupAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      try {
        const source = audioContext.createMediaElementSource(videoEl);
        gainNode = audioContext.createGain();
        gainNode.gain.value = 1.0; // normal by default
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);
      } catch (e) {
        console.warn('AudioContext createMediaElementSource failed', e);
      }
    }
    audioContext && audioContext.resume().catch(()=>{});
  }

  // Ensure audio resume on user gesture
  function ensureAudioPlayback() {
    try {
      if (!audioContext) setupAudioContext();
      if (audioContext && audioContext.state === 'suspended') audioContext.resume().catch(()=>{});
      if (videoEl.paused) videoEl.play().catch(()=>{});
    } catch(e){}
  }
  document.addEventListener('click', ensureAudioPlayback, { passive: true });
  document.addEventListener('touchstart', ensureAudioPlayback, { passive: true, once: true });
  videoEl.addEventListener('play', ensureAudioPlayback);
  videoEl.addEventListener('playing', ensureAudioPlayback);

  /********************************************************
   * Smart MKV prefetch (keeps your original behavior)
   * -> REPLACED/ENHANCED: MKV Low-Buffering System (Heroku-friendly)
   ********************************************************/

  // mkvPrefetchConfig: conservative defaults tuned for low-bandwidth hosts (Heroku/free)
  const mkvPrefetchConfig = {
    initialMB: 2,        // initial prefetch on load (2 MB)
    seekMB: 4,           // chunk to prefetch on long seeks (~4 MB)
    maxMB: 6,            // maximum allowed in adaptive increase (~6 MB)
    hintKB: 128,         // background hint size (in KB)
    seekThresholdSec: 8, // consider long seek if > 8s
    controllerTimeout: 6000
  };

  // helper: convert MB to bytes
  function MB(n){ return Math.floor(n * 1024 * 1024); }
  function KB(n){ return Math.floor(n * 1024); }

  // lightweight MKV prefetch using worker (so it doesn't block main-thread heavy fetch)
  async function smartMKVPrefetch() {
    try {
      const src = videoEl.currentSrc || videoEl.src;
      if (!src || !src.endsWith('.mkv')) return;

      // use worker to prefetch initial small chunk
      try {
        const start = 0;
        const end = MB(mkvPrefetchConfig.initialMB) - 1;
        prefetchWorker.postMessage({ id: Date.now(), task: 'prefetch', src, range: `bytes=${start}-${end}`, timeout: mkvPrefetchConfig.controllerTimeout });
        console.log(`âœ… MKV lightweight initial prefetch requested (${mkvPrefetchConfig.initialMB}MB)`);
      } catch(e){ console.warn('MKV prefetch worker error', e); }
    } catch (e) {
      console.log('â„¹ï¸ MKV Prefetch skipped:', e && e.message);
    }
  }
  // call immediately (non-blocking)
  smartMKVPrefetch();

  /********************************************************
   * MKV long-seek optimizer (VLC-like logic) â€” enhanced
   * - Uses workers to prefetch around seek targets
   * - Conservative sizes (4MB) to suit Heroku/free-tier
   ********************************************************/
  let lastSeek = 0;
  let isPrefetching = false;
  videoEl.addEventListener('seeking', async () => {
    ensureAudioPlayback();
    const currentTime = videoEl.currentTime;
    const jumpDiff = Math.abs(currentTime - lastSeek);
    lastSeek = currentTime;

    // Only run MKV long-seek optimization on MKV sources
    if (!(videoEl.currentSrc && videoEl.currentSrc.endsWith('.mkv'))) return;
    if (isPrefetching) return;

    // Only act on significant jumps
    if (jumpDiff < mkvPrefetchConfig.seekThresholdSec) return;

    isPrefetching = true;
    try {
      const src = videoEl.currentSrc;
      // conservative bitrate estimate
      const bitrateEstimate = 1.0 * 1024 * 1024; // 1 MB/s estimate
      const targetStart = Math.max(0, Math.floor(currentTime * bitrateEstimate) - MB(Math.floor(mkvPrefetchConfig.seekMB/2)));
      const prefetchSize = MB(mkvPrefetchConfig.seekMB);
      const startByte = Math.max(0, targetStart);
      const endByte = startByte + prefetchSize - 1;

      // Use worker to prefetch (non-blocking)
      seekWorker.postMessage({ id: Date.now(), task: 'prefetch', src, range: `bytes=${startByte}-${endByte}`, timeout: mkvPrefetchConfig.controllerTimeout });
      console.log(`ðŸŽ¯ MKV seek prefetch (worker) requested: ${Math.round(prefetchSize/1048576)}MB @ ${Math.round(startByte/1048576)}MB`);
    } catch (e) {
      console.log('âš ï¸ MKV seek prefetch failed:', e && e.message);
    } finally {
      setTimeout(() => (isPrefetching = false), 900); // small cool-down
    }
  });

  /********************************************************
   * Background MKV hinting (very small, Heroku-friendly)
   * - Sends tiny range hints periodically (~128 KB) to keep TCP/TLS
   *   connection warm and reduce latency on subsequent requests
   ********************************************************/
  let mkvHintInterval = null;
  function startMKVHints() {
    if (mkvHintInterval) return;
    mkvHintInterval = setInterval(async () => {
      try {
        const src = videoEl.currentSrc || videoEl.src;
        if (!src || !src.endsWith('.mkv')) return;
        // pick a small range near currentTime + lookahead (so it warms nearby bytes)
        const lookaheadSec = Math.max(8, Math.floor(videoEl.currentTime + 8));
        const bitrate = 1.0 * 1024 * 1024; // same conservative estimate
        const bytePos = Math.max(0, Math.floor(lookaheadSec * bitrate));
        const hintSize = KB(mkvPrefetchConfig.hintKB);
        const start = Math.max(0, bytePos);
        const end = start + hintSize - 1;
        prefetchWorker.postMessage({ id: Date.now(), task: 'prefetch', src, range: `bytes=${start}-${end}`, timeout: 3000 });
        // silent, no heavy logs to not flood console
      } catch (e) { /* ignore */ }
    }, 3500); // every ~3.5s (small but regular)
  }
  function stopMKVHints() {
    if (mkvHintInterval) {
      clearInterval(mkvHintInterval);
      mkvHintInterval = null;
    }
  }
  // Start MKV hints when video loaded & source is MKV
  videoEl.addEventListener('loadedmetadata', () => {
    try {
      const src = videoEl.currentSrc || videoEl.src;
      if (src && src.endsWith('.mkv')) startMKVHints();
    } catch(e){}
  });
  // Stop hints on unload
  window.addEventListener('beforeunload', () => stopMKVHints());

  /********************************************************
   * Intelligent resume & buffer stabilization (original)
   ********************************************************/
  let seekTimeout;
  videoEl.addEventListener('seeking', () => {
    clearTimeout(seekTimeout);
    try { videoEl.pause(); } catch(e){}
    seekTimeout = setTimeout(() => {
      if (videoEl.readyState >= 3) {
        videoEl.play().catch(()=>{});
      } else {
        const resumeCheck = setInterval(() => {
          if (videoEl.readyState >= 3) {
            clearInterval(resumeCheck);
            videoEl.play().catch(()=>{});
          }
        }, 150);
        setTimeout(() => clearInterval(resumeCheck), 4000);
      }
    }, 120);
  });

  /********************************************************
   * Landscape (custom) button only â€” function; appended in ready()
   ********************************************************/
  function createLandscapeButton() {
    const btn = document.createElement('button');
    btn.className = 'plyr__control landscape-btn';
    btn.type = 'button';
    Object.assign(btn.style, {
      display:'flex',flexDirection:'column',alignItems:'center',justifyContent:'center',
      fontSize:'12px',color:'#fff',cursor:'pointer',padding:'5px 8px',marginLeft:'6px',
      WebkitTapHighlightColor:'transparent', background:'transparent', border:'none'
    });
    btn.innerHTML = `
      <i class="fas fa-expand" style="font-size:18px; color:#fff;"></i>
      <span style="font-size:10px; color:#00ffcc; font-weight:bold;">Landscape</span>
    `;
    let isLandscape = false;
    btn.addEventListener('click', async () => {
      ensureAudioPlayback();
      const label = btn.querySelector('span');
      try {
        if (!isLandscape) {
          if (player && player.fullscreen) await player.fullscreen.enter();
          if (screen.orientation?.lock) await screen.orientation.lock('landscape');
          label.innerText = 'Portrait';
          label.style.color = '#ff9933';
          isLandscape = true;
        } else {
          if (player && player.fullscreen) await player.fullscreen.exit();
          if (screen.orientation?.unlock) screen.orientation.unlock();
          label.innerText = 'Landscape';
          label.style.color = '#00ffcc';
          isLandscape = false;
        }
      } catch (e) { console.log(e); }
    });
    // ensure first click unlocks audio
    btn.addEventListener('click', ensureAudioPlayback);
    return btn;
  }

  /************************************************************************
   * ADVANCED OPTIMIZATIONS (kept intact)
   * - workers (prefetch + seek)
   * - adaptive prefetch controller
   * - smart retries
   * - 100ms seek stabilizer
   * - network estimator + background prefetch
   * - MSE scaffold for MP4
   ************************************************************************/

  function bytesToMB(n){ return (n/1048576).toFixed(2); }

  const net = {
    lastRTT: 0, kbpsEstimate: null,
    async estimate(src) {
      try {
        const t0 = performance.now();
        const controller = new AbortController();
        setTimeout(()=>controller.abort(), 4000);
        const res = await fetch(src, { headers: { Range: 'bytes=0-65535' }, signal: controller.signal });
        const t1 = performance.now();
        if (!res.ok) return null;
        const len = +(res.headers.get('Content-Length') || 65536);
        const ms = Math.max(1, t1 - t0);
        this.kbpsEstimate = (len * 8) / ms;
        this.lastRTT = ms;
        console.log(`ðŸŒ Speed estimate: ${bytesToMB(len)} MB chunk in ${Math.round(ms)} ms`);
        return this.kbpsEstimate;
      } catch (e) { return null; }
    }
  };

  const workerCode = `
    self.onmessage = async (e) => {
      const { id, task, src, range, timeout } = e.data;
      if (!src || !range) { self.postMessage({ id, ok:false, task, error:'no-src-or-range' }); return; }
      try {
        const controller = new AbortController();
        const to = setTimeout(()=>controller.abort(), timeout || 8000);
        const r = await fetch(src, { headers: { Range: range }, signal: controller.signal, cache:'no-store' });
        clearTimeout(to);
        if (!r.ok) { self.postMessage({ id, ok:false, task, status:r.status }); return; }
        const blob = await r.blob();
        self.postMessage({ id, ok:true, task, range, size: blob.size });
      } catch (err) {
        self.postMessage({ id, ok:false, task, error: String(err) });
      }
    };
  `;
  const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
  const workerURL = URL.createObjectURL(workerBlob);
  const prefetchWorker = new Worker(workerURL);
  const seekWorker = new Worker(workerURL);

  prefetchWorker.onmessage = (e) => { /* optional logging */ };
  seekWorker.onmessage = (e) => { /* optional logging */ };

  const adaptive = {
    minMB: 8, maxMB: 12,
    getChunk(currentTime, src, preferLarger=false){
      const est = net.kbpsEstimate;
      const sizeMB = preferLarger ? this.maxMB : this.minMB;
      const chosenMB = (est && est > 0.03) ? this.maxMB : sizeMB;
      const bitrate = 1.2 * 1024 * 1024;
      const start = Math.max(0, Math.floor(currentTime * bitrate));
      const chunk = Math.floor(chosenMB * 1024 * 1024);
      return { start, end: start + chunk - 1, chunkBytes: chunk };
    }
  };

  async function smartFetchRange(src, range, attempts = 2, timeout = 6000) {
    for (let i=0;i<attempts;i++){
      try {
        const controller = new AbortController();
        setTimeout(()=>controller.abort(), timeout);
        const res = await fetch(src, { headers: { Range: range }, signal: controller.signal, cache:'no-store' });
        if (res && res.ok) return res;
      } catch (e) { /* retry */ }
      await new Promise(r=>setTimeout(r, 200 + i*100));
    }
    throw new Error('range-fetch-failed');
  }

  // 100ms micro-stabilizer for seeking (keeps original idea)
  let advSeekTimer;
  videoEl.addEventListener('seeking', () => {
    clearTimeout(advSeekTimer);
    advSeekTimer = setTimeout(() => {
      if (videoEl.readyState < 3) {
        try {
          const src = videoEl.currentSrc || videoEl.src;
          if (!src) return;
          const bitrate = 1.2 * 1024 * 1024;
          const start = Math.max(0, Math.floor(videoEl.currentTime * bitrate));
          const end = start + (4 * 1024 * 1024) - 1;
          seekWorker.postMessage({ id:Date.now(), task:'prefetch', src, range:`bytes=${start}-${end}`, timeout:4000 });
        } catch(e){}
      }
    }, 100);
  });

  // Background prefetch loop
  let backgroundPrefetchInterval = null;
  function startBackgroundPrefetch() {
    if (backgroundPrefetchInterval) return;
    backgroundPrefetchInterval = setInterval(async () => {
      try {
        const src = videoEl.currentSrc || videoEl.src;
        if (!src) return;
        await net.estimate(src).catch(()=>{});
        const lookahead = Math.max(10, Math.floor(videoEl.currentTime + 8));
        const { start, end } = adaptive.getChunk(lookahead, src, false);
        prefetchWorker.postMessage({ id:Date.now(), task:'prefetch', src, range:`bytes=${start}-${end}`, timeout:5000 });
      } catch(e){}
    }, 1000);
  }
  function stopBackgroundPrefetch() {
    if (backgroundPrefetchInterval) {
      clearInterval(backgroundPrefetchInterval); backgroundPrefetchInterval = null;
    }
  }
  startBackgroundPrefetch();

  // initial adaptive attempt
  (async function initAdaptive() {
    try {
      const src = videoEl.currentSrc || videoEl.src;
      if (!src) return;
      await net.estimate(src);
      const { start, end } = adaptive.getChunk(0, src, false);
      prefetchWorker.postMessage({ id:Date.now(), task:'prefetch', src, range:`bytes=${start}-${end}`, timeout:5000 });
    } catch(e){}
  })();

  // MSE scaffold (best-effort) for MP4
  let msSupported = !!window.MediaSource;
  let mseController = { enabled:false, mediaSource:null, sourceBuffer:null, appendQueue:[] };

  async function tryInitMSE() {
    try {
      const src = videoEl.currentSrc || videoEl.src;
      if (!src || !msSupported) return;
      if (!src.endsWith('.mp4')) return;
      const mime = 'video/mp4; codecs="avc1.42E01E,mp4a.40.2"';
      if (!MediaSource.isTypeSupported(mime)) return;
      const ms = new MediaSource();
      mseController.mediaSource = ms;
      videoEl.src = URL.createObjectURL(ms);
      ms.addEventListener('sourceopen', async () => {
        try {
          const sb = ms.addSourceBuffer(mime);
          mseController.sourceBuffer = sb; mseController.enabled = true;
          const res = await smartFetchRange(src, 'bytes=0-1258291', 2, 6000).catch(()=>null);
          if (!res) return;
          const ab = await res.arrayBuffer();
          const appendChunk = () => {
            if (!mseController.sourceBuffer || mseController.sourceBuffer.updating) { setTimeout(appendChunk, 50); return; }
            try { mseController.sourceBuffer.appendBuffer(ab); console.log('MSE: appended initial chunk'); } catch(err){ console.log('MSE append error', err); }
          }; appendChunk();
        } catch(err){ console.log('MSE open error', err); }
      });
    } catch(e){ console.log('MSE init skipped', e); }
  }
  tryInitMSE();

  // cleanup on unload
  window.addEventListener('beforeunload', () => {
    try { prefetchWorker.terminate(); seekWorker.terminate(); } catch(e){}
    stopBackgroundPrefetch();
    if (mseController.mediaSource) { try { mseController.mediaSource.endOfStream(); } catch(e){} }
  });

  /************************************************************************
   * AUDIO + VIDEO SYNC: robust synchronizer (keeps audio/video in sync)
   ************************************************************************/

  let audioOffset = 0;
  let syncInterval = null;
  let emaRate = 1.0;
  const EMA_ALPHA = 0.18;
  const POLL_MS = 120;

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function isTimeBuffered(time) {
    try {
      const buf = videoEl.buffered;
      for (let i = 0; i < buf.length; i++) {
        if (time >= buf.start(i) - 0.05 && time <= buf.end(i) + 0.05) {
          return { start: buf.start(i), end: buf.end(i) };
        }
      }
    } catch(e){}
    return null;
  }

  function refreshAudioOffset() {
    if (!audioContext) return;
    try {
      audioOffset = audioContext.currentTime - videoEl.currentTime;
      const outLatency = (audioContext.outputLatency || audioContext.baseLatency || 0);
      audioOffset -= outLatency;
    } catch(e){}
  }

  function ensureAudioReady() {
    if (!audioContext) return;
    audioContext.resume().catch(()=>{});
    setTimeout(refreshAudioOffset, 60);
  }

  function attemptBufferedRender(targetTime, timeoutMs = 5000) {
    return new Promise((resolve) => {
      const start = performance.now();
      let settled = false;
      if (isTimeBuffered(targetTime)) return resolve(true);
      if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
        try {
          const frameCheck = () => {
            try {
              videoEl.requestVideoFrameCallback(() => {
                if (!settled && (isTimeBuffered(targetTime) || videoEl.currentTime >= (targetTime - 0.1))) {
                  settled = true; resolve(true);
                } else if (!settled && (performance.now() - start > timeoutMs)) {
                  settled = true; resolve(false);
                } else if (!settled) frameCheck();
              });
            } catch(e){}
          };
          frameCheck();
        } catch(e){}
      }
      const poll = setInterval(() => {
        if (isTimeBuffered(targetTime) || videoEl.readyState >= 3 || (performance.now() - start > timeoutMs)) {
          clearInterval(poll);
          if (!settled) { settled = true; resolve(isTimeBuffered(targetTime) || videoEl.readyState >= 3); }
        }
      }, 100);
      setTimeout(() => { if (!settled) { settled = true; clearInterval(poll); resolve(false); } }, timeoutMs + 120);
    });
  }

  function syncTick() {
    if (!audioContext || videoEl.paused || videoEl.readyState < 2) {
      emaRate = 1.0;
      try { if (videoEl.playbackRate !== 1.0) videoEl.playbackRate = 1.0; } catch(e){}
      return;
    }
    let expectedAudioTime = audioContext.currentTime - audioOffset;
    if (typeof audioContext.outputLatency === 'number') expectedAudioTime -= audioContext.outputLatency;
    else if (typeof audioContext.baseLatency === 'number') expectedAudioTime -= audioContext.baseLatency;

    const vtime = videoEl.currentTime;
    let drift = expectedAudioTime - vtime;
    if (!isFinite(drift) || Math.abs(drift) > 300) { refreshAudioOffset(); return; }

    // big drift => attempt safe seek to buffered region
    if (Math.abs(drift) > 0.45) {
      const targetTime = vtime + drift;
      try {
        const src = videoEl.currentSrc || videoEl.src;
        if (src) {
          const bitrate = 1.2 * 1024 * 1024;
          const startByte = Math.max(0, Math.floor(targetTime * bitrate) - (4 * 1024 * 1024));
          const endByte = startByte + (adaptive.maxMB * 1024 * 1024);
          seekWorker.postMessage({ id:Date.now(), task:'prefetch', src, range:`bytes=${startByte}-${endByte}`, timeout:9000 });
        }
      } catch(e){}
      const buf = isTimeBuffered(targetTime);
      if (buf) {
        const safeTarget = clamp(targetTime, buf.start + 0.02, buf.end - 0.02);
        try {
          videoEl.pause();
          videoEl.currentTime = safeTarget;
          attemptBufferedRender(safeTarget, 4200).then((ok) => {
            ensureAudioReady();
            setTimeout(()=> { videoEl.play().catch(()=>{}); refreshAudioOffset(); }, 120);
          });
        } catch (e){}
        return;
      }
    }
// small drift -> gentle playbackRate correction (exponential smoothing)
    const gain = 0.12;
    let rawTargetRate = 1 - clamp(drift * gain, -0.06, 0.06);
    if (Math.abs(drift) < 0.035) rawTargetRate = 1.0;
    emaRate = emaRate + (rawTargetRate - emaRate) * EMA_ALPHA;
    const finalRate = clamp(emaRate, 0.94, 1.06);
    if (Math.abs(videoEl.playbackRate - finalRate) > 0.0009) {
      try { videoEl.playbackRate = finalRate; } catch(e){}
    }
    if (Math.abs(drift) > 0.8) refreshAudioOffset();
  }

  function startSyncLoop() {
    if (syncInterval) return;
    refreshAudioOffset();
    syncInterval = setInterval(syncTick, POLL_MS);
    setTimeout(syncTick, 40);
  }
  function stopSyncLoop() {
    if (!syncInterval) return;
    clearInterval(syncInterval);
    syncInterval = null;
    try { videoEl.playbackRate = 1.0; } catch(e){}
    emaRate = 1.0;
  }

  // seeking handlers: pause sync and suspend audio pipeline temporarily
  let savedGainValue = 1.0;
  videoEl.addEventListener('seeking', () => {
    stopSyncLoop();
    if (audioContext && audioContext.state === 'running') audioContext.suspend().catch(()=>{});
    try { videoEl.pause(); } catch(e){}
  });

  videoEl.addEventListener('seeked', async () => {
    try {
      if (gainNode && audioContext) {
        savedGainValue = gainNode.gain.value || 1.0;
        gainNode.gain.cancelScheduledValues(audioContext.currentTime);
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      }
    } catch(e){}

    try {
      const src = videoEl.currentSrc || videoEl.src;
      if (src) {
        const bitrate = 1.2 * 1024 * 1024;
        const startByte = Math.max(0, Math.floor(videoEl.currentTime * bitrate) - (2 * 1024 * 1024));
        const endByte = startByte + (adaptive.maxMB * 1024 * 1024);
        seekWorker.postMessage({ id:Date.now(), task:'prefetch', src, range:`bytes=${startByte}-${endByte}`, timeout:9000 });
      }
    } catch(e){}

    const target = videoEl.currentTime;
    const ok = await attemptBufferedRender(target, 5200);

    ensureAudioReady();
    refreshAudioOffset();

    setTimeout(() => {
      try {
        if (gainNode && audioContext) {
          gainNode.gain.setValueAtTime(savedGainValue || 1.0, audioContext.currentTime);
        }
      } catch(e){}
      startSyncLoop();
      syncTick();
    }, 140);
  });

  // play / playing listeners to (re)start sync loop
  videoEl.addEventListener('play', () => {
    ensureAudioReady();
    refreshAudioOffset();
    startSyncLoop();
  });
  videoEl.addEventListener('playing', () => {
    refreshAudioOffset();
    syncTick();
    startSyncLoop();
  });
  videoEl.addEventListener('ratechange', () => { emaRate = clamp(videoEl.playbackRate, 0.5, 2.0); });

  // wrap setupAudioContext to start sync after audio created
  const _origSetup = setupAudioContext;
  setupAudioContext = function() {
    _origSetup();
    setTimeout(() => { try { refreshAudioOffset(); startSyncLoop(); } catch(e){} }, 80);
  };

  // optional helper: attachSource (HLS/DASH/fallback)
  async function attachSource(src) {
    if (!src) return;
    if (src.endsWith('.m3u8') && window.Hls && Hls.isSupported()) {
      try {
        const hls = new Hls({ lowLatencyMode: true, maxBufferLength: 30 });
        hls.loadSource(src);
        hls.attachMedia(videoEl);
        console.log('HLS attached');
        return;
      } catch (e) { console.warn('HLS attach failed', e); }
    }
    if (src.endsWith('.mpd') && window.dashjs) {
      try {
        const playerDash = dashjs.MediaPlayer().create();
        playerDash.initialize(videoEl, src, false);
        console.log('DASH attached');
        return;
      } catch (e) { console.warn('DASH attach failed', e); }
    }
    videoEl.src = src;
  }
  window.playerAttach = attachSource;

  console.log('âœ… Player initialized â€” limited controls + advanced optimizations + sync active');
});
</script>

