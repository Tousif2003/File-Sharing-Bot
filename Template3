<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta property="og:image" content="https://i.ibb.co/M8S0Zzj/live-streaming.png" itemprop="thumbnailUrl">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ heading }}</title>

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway|Delius">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">

    <!-- Plyr Video Player -->
    <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css">

    <style>
        body {
            font-family: sans-serif;
            font-size: 16px;
            margin: 0;
            padding: 0;
        }

        marquee {
            font-size: 22px;
            color: black;
            font-family: serif;
        }

        .set-container {
            padding: 15px;
        }

        #player-container {
            margin: 10px 0;
        }

        #info-box {
            border: 1px solid #140cf0;
            border-radius: 10px;
            padding: 10px;
            margin: 10px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            word-wrap: break-word;
        }

        .stream-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stream-options a {
            display: flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 6px;
            background-color: #2D76FF;
            color: #fff;
            transition: all 0.3s;
        }

        .stream-options a:hover {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            transform: scale(1.05);
        }

        .download-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            padding: 8px 12px;
            margin-bottom: 20px;
            border-radius: 6px;
            background-color: #28a745;
            color: #fff;
            font-weight: bold;
            transition: all 0.3s;
        }

        .download-btn:hover {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            transform: scale(1.05);
        }

        footer {
            font-size: 12px;
            color: #7b89a3;
            padding: 20px 10px 0 10px;
            border-top: 1px solid #c2cee3;
            text-align: center;
        }

        footer a {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div class="set-container">

    <!-- Marquee Header -->
    <header>
        <marquee bgcolor="#808080">
            <div id="file-name">{{ file_name }}</div>
        </marquee>
    </header>

    <!-- Video Player -->
    <div id="player-container">
        <video id="player" playsinline preload="metadata" controlsList="nodownload" aria-label="Video player">
            <source src="{{ src }}" type="video/mp4">
            <p>Your browser does not support the video tag. Please <a href="{{ src }}" download>download the video</a> instead.</p>
        </video>
    </div>

    <!-- Stream Options -->
<p class="fancy-text">ꜱᴛʀᴇᴀᴍ ᴏᴘᴛɪᴏɴꜱ</p>

<style>
.fancy-text {
  font-weight: bold;
  font-size: 1rem;
  color: #ff66cc; /* pink */
}
</style>
<div class="stream-options" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;">

    <!-- VLC -->
    <a href="intent:{{ src }}#Intent;type=video/*;action=android.intent.action.VIEW;package=org.videolan.vlc;S.title={{ file_name }};S.browser_fallback_url=https://play.google.com/store/apps/details?id=org.videolan.vlc;end"
       style="background-color: #f8f9ff; border-radius: 12px; height: 50px; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 8px rgba(0,0,0,0.08); overflow: hidden; transition: 0.3s; width: 100%;">
        <img src="https://i.ibb.co/GtnGhBV/videolan-vlc-logo-icon-170258.png" alt="VLC" style="width: 100%; height: 100%; object-fit: contain;">
    </a>

    <!-- XPlayer -->
    <a href="intent:{{ src }}#Intent;type=video/*;action=android.intent.action.VIEW;package=video.player.videoplayer;S.title={{ file_name }};S.browser_fallback_url=https://play.google.com/store/apps/details?id=video.player.videoplayer;end"
       style="background-color: #f8f9ff; border-radius: 12px; height: 50px; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 8px rgba(0,0,0,0.08); overflow: hidden; transition: 0.3s; width: 100%;">
        <img src="https://i.ibb.co/pByqt2ZK/x.png" alt="XPlayer" style="width: 100%; height: 100%; object-fit: contain;">
    </a>

    <!-- KMPlayer -->
    <a href="intent:{{ src }}#Intent;type=video/*;action=android.intent.action.VIEW;package=com.kmplayer;S.title={{ file_name }};S.browser_fallback_url=https://play.google.com/store/apps/details?id=com.kmplayer;end"
       style="background-color: #f8f9ff; border-radius: 12px; height: 50px; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 8px rgba(0,0,0,0.08); overflow: hidden; transition: 0.3s; width: 100%;">
        <img src="https://i.ibb.co/bjPYQjkZ/x.png" alt="KMPlayer" style="width: 100%; height: 100%; object-fit: contain;">
    </a>

    <!-- Playit -->
    <a href="intent:{{ src }}#Intent;type=video/*;action=android.intent.action.VIEW;package=com.playit.videoplayer;S.title={{ file_name }};S.browser_fallback_url=https://play.google.com/store/apps/details?id=com.playit.videoplayer;end"
       style="background-color: #f8f9ff; border-radius: 12px; height: 50px; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 8px rgba(0,0,0,0.08); overflow: hidden; transition: 0.3s; width: 100%;">
        <img src="https://i.ibb.co/JsDNHgz/c0C4vnAa.png" alt="Playit" style="width: 100%; height: 100%; object-fit: contain;">
    </a>
</div>

<!-- Download Button -->
<a href="{{ src }}" download
   style="display: flex; align-items: center; justify-content: center; gap: 10px; text-decoration: none; background-color: #2D76FF; color: #fff; border-radius: 12px; padding: 15px; margin-top: 15px; font-weight: bold; font-size: 18px; box-shadow: 0 0 15px #2d76ff; transition: all 0.3s;">
    <i class="fas fa-download" style="font-size: 20px;"></i> Download Now
</a>

<style>
/* Pop & Bounce effect */
@keyframes popBounce {
  0% { transform: scale(0.8); }
  50% { transform: scale(1.1); }
  70% { transform: scale(0.95); }
  100% { transform: scale(1); }
}

/* Base style for all buttons: visible but scaled down initially */
.stream-options a,
.card.card-body {
  transform: scale(0.8); /* start smaller */
  animation: popBounce 0.6s ease forwards;
  animation-fill-mode: forwards;
}

/* Sequential animation: initial wait 1s, then each button 0.5s after previous */
.stream-options a:nth-child(1),
.card.card-body:nth-child(1) { animation-delay: 1s; }
.stream-options a:nth-child(2),
.card.card-body:nth-child(2) { animation-delay: 1.5s; }
.stream-options a:nth-child(3),
.card.card-body:nth-child(3) { animation-delay: 2s; }
.stream-options a:nth-child(4),
.card.card-body:nth-child(4) { animation-delay: 2.5s; }
.stream-options a:nth-child(5),
.card.card-body:nth-child(5) { animation-delay: 3s; }
.stream-options a:nth-child(6),
.card.card-body:nth-child(6) { animation-delay: 3.5s; }

/* Remove old fade/slide effects */
.fadeInLeft, .fadeInRight, .shakeX {
  animation-name: none !important;
}
</style>

    <!-- Info Box -->
    <div id="info-box">
        <p style="font-size: 15px; color:#120e0e;">
           <span style="color:#ff0000;"><u><b>𝐍𝐨𝐭𝐞</b></u></span> : ɪꜰ ʏᴏᴜ ꜰɪɴᴅ ᴀɴʏ ʙʀᴏᴋᴇɴ ʟɪɴᴋ ᴛʜᴇɴ ᴘʟᴇᴀsᴇ ʀᴇᴘᴏʀᴛ ᴛᴏ ᴍʏ 
            <a href="https://telegram.me/FilmymodOwner_Bot" style="color: blue"><b>sᴜᴘᴘᴏʀᴛ ᴛᴇᴀᴍ</b></a>
        </p>
    </div>

    <!-- Main Updates -->
    <div class="mainupdates" style="text-align:center; margin-top:20px;">
        <div style="margin-bottom: 10px;">𝐉𝐨𝐢𝐧 𝐎𝐮𝐫 𝐌𝐚𝐢𝐧 𝐂𝐡𝐚𝐧𝐧𝐞𝐥 𝐅𝐨𝐫 𝐌𝐨𝐫𝐞 𝐔𝐩𝐝𝐚𝐭𝐞𝐬 💖</div>
        <a href="https://telegram.me/FilmyMod123">
            <img src="https://img.shields.io/badge/Updates- Channel -blueviolet?style=for-the-badge" alt="Channel">
        </a>
    </div>

</div>

<!-- ===========================
     ORIGINAL PLAYER + PLYR (UNCHANGED)
     (keep this part as your original)
   =========================== -->

<!-- ✅ Font Awesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

<!-- ✅ Plyr CSS & JS -->
<link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css">
<script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>

<!-- ✅ HLS & DASH (optional adaptive) -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script src="https://cdn.dashjs.org/latest/dash.all.min.js"></script>

<style>
.plyr__control:focus {
  outline: none;
  -webkit-tap-highlight-color: transparent;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', () => {
  /************************************************************************
   * ==========================
   * ORIGINAL PLAYER (UNCHANGED)
   * ==========================
   * This block is exactly your original code (kept intact).
   ************************************************************************/

  const videoEl = document.querySelector('#player');
  videoEl.setAttribute('preload', 'auto');
  videoEl.setAttribute('playsinline', '');
  videoEl.setAttribute('crossorigin', 'anonymous');

  // 🎬 Initialize Plyr UI
  const player = new Plyr(videoEl, {
    controls: [
      'play-large','rewind','play','fast-forward','progress','current-time','duration'
    ]
  });

  // ============================
  // 🔊 Audio Context + Boost
  // ============================
  let audioContext, gainNode;
  function setupAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioContext.createMediaElementSource(videoEl);
      gainNode = audioContext.createGain();

      // ✅ Start with boosted audio (2x loudness)
      gainNode.gain.value = 2.0;

      source.connect(gainNode);
      gainNode.connect(audioContext.destination);
    }
    audioContext.resume().catch(()=>{});
  }

  function resumeAudio() {
    setupAudioContext();
    if (audioContext) audioContext.resume().catch(()=>{});
    // ✅ Force playback to always stay at 1x speed
    videoEl.playbackRate = 1.0;
  }

  // =================================================
  // ⚡ Smart MKV Prefetch + Adaptive Buffer System
  // =================================================
  async function smartMKVPrefetch() {
    try {
      const src = videoEl.currentSrc || videoEl.src;
      if (!src.endsWith('.mkv')) return;

      // Initial Prefetch — load 8 MB before playback
      const controller = new AbortController();
      setTimeout(() => controller.abort(), 5000);
      const res = await fetch(src, {
        headers: { Range: 'bytes=0-8388607' },
        signal: controller.signal
      });
      if (res.ok) console.log('✅ Initial MKV Prefetch (8MB)');
    } catch (e) {
      console.log('ℹ️ MKV Prefetch skipped:', e.message);
    }
  }
  smartMKVPrefetch();

  // =================================================
  // 🚀 MKV Smart Long-Seek Optimizer (VLC-like logic)
  // =================================================
  let lastSeek = 0;
  let isPrefetching = false;
  videoEl.addEventListener('seeking', async () => {
    resumeAudio();

    const currentTime = videoEl.currentTime;
    const jumpDiff = Math.abs(currentTime - lastSeek);
    lastSeek = currentTime;

    if (!videoEl.currentSrc.endsWith('.mkv')) return;
    if (isPrefetching) return;
    if (jumpDiff < 8) return; // small seek ignore

    isPrefetching = true;

    const src = videoEl.currentSrc;
    const bitrateEstimate = 1.2 * 1024 * 1024; // ~1.2MB/sec bitrate estimate
    const startByte = Math.max(0, Math.floor(currentTime * bitrateEstimate));
    const prefetchSize = currentTime > 1800 ? 16 * 1024 * 1024 : 8 * 1024 * 1024;
    const endByte = startByte + prefetchSize;

    try {
      const controller = new AbortController();
      setTimeout(() => controller.abort(), 6000);
      const res = await fetch(src, {
        headers: { Range: `bytes=${startByte}-${endByte}` },
        signal: controller.signal
      });
      if (res.ok) console.log(`🎯 MKV Prefetched ${Math.round(prefetchSize/1048576)}MB @${Math.round(startByte/1048576)}MB`);
    } catch (e) {
      console.log('⚠️ MKV seek prefetch failed:', e.message);
    }

    setTimeout(() => (isPrefetching = false), 800);
  });

  // =================================================
  // 🧠 Intelligent Resume & Buffer Stabilization
  // =================================================
  let seekTimeout;
  videoEl.addEventListener('seeking', () => {
    clearTimeout(seekTimeout);
    videoEl.pause();
    seekTimeout = setTimeout(() => {
      if (videoEl.readyState >= 3) {
        videoEl.play().catch(()=>{});
      } else {
        const resumeCheck = setInterval(() => {
          if (videoEl.readyState >= 3) {
            clearInterval(resumeCheck);
            videoEl.play().catch(()=>{});
          }
        }, 150);
        setTimeout(() => clearInterval(resumeCheck), 4000);
      }
    }, 120);
  });

  // =================================================
  // 🧭 Landscape Toggle Button
  // =================================================
  const rotateBtn = document.createElement('button');
  rotateBtn.classList.add('plyr__control');
  rotateBtn.type = 'button';
  Object.assign(rotateBtn.style, {
    display:'flex',flexDirection:'column',alignItems:'center',justifyContent:'center',
    fontSize:'12px',color:'#fff',cursor:'pointer',padding:'5px 8px',marginLeft:'5px',
    WebkitTapHighlightColor:'transparent'
  });
  rotateBtn.innerHTML = `
    <i class="fas fa-expand" style="font-size:18px; color:#fff;"></i>
    <span style="font-size:10px; color:#00ffcc; font-weight:bold;">Landscape</span>
  `;
  player.elements.controls.appendChild(rotateBtn);

  let isLandscape = false;
  rotateBtn.addEventListener('click', async () => {
    resumeAudio();
    const label = rotateBtn.querySelector('span');
    try {
      if (!isLandscape) {
        await player.fullscreen.enter();
        if (screen.orientation?.lock) await screen.orientation.lock('landscape');
        label.innerText = 'Portrait';
        label.style.color = '#ff9933';
        isLandscape = true;
      } else {
        if (document.fullscreenElement) await player.fullscreen.exit();
        if (screen.orientation?.unlock) screen.orientation.unlock();
        label.innerText = 'Landscape';
        label.style.color = '#00ffcc';
        isLandscape = false;
      }
    } catch (e) { console.log(e); }
  });

  // =================================================
  // 🔊 Audio Boost Button
  // =================================================
  const boostBtn = document.createElement('button');
  boostBtn.classList.add('plyr__control');
  Object.assign(boostBtn.style,{
    display:'flex',flexDirection:'column',alignItems:'center',justifyContent:'center',
    fontSize:'12px',color:'#fff',cursor:'pointer',padding:'5px 8px',marginLeft:'5px',
    textShadow:'0 0 5px #ff33aa,0 0 10px #ff33aa',transition:'transform .3s ease'
  });
  boostBtn.innerHTML = `
    <i class="fas fa-volume-up" style="font-size:18px; color:#ff33aa;"></i>
    <span style="font-size:10px; color:#ff66cc; font-weight:bold;">Audio Boost</span>
  `;
  player.elements.controls.appendChild(boostBtn);

  boostBtn.addEventListener('click', () => {
    resumeAudio();
    if (gainNode) {
      gainNode.gain.cancelScheduledValues(audiocontext?.currentTime || 0);
      gainNode.gain.setValueAtTime(gainNode.gain.value, audiocontext?.currentTime || 0);
      gainNode.gain.linearRampToValueAtTime(3.0, (audiocontext?.currentTime || 0) + 0.5);
    }
    boostBtn.style.transform = 'scale(1.2)';
    setTimeout(() => boostBtn.style.opacity = '0', 300);
    setTimeout(() => boostBtn.remove(), 600);
  });

  // =================================================
  // 🚀 Autoplay + Resume Audio
  // =================================================
  videoEl.playbackRate = 1.0;
  ['play','pause','click','seeked'].forEach(evt =>
    videoEl.addEventListener(evt,resumeAudio)
  );

  /************************************************************************
   * ==========================
   * ADVANCED OPTIMIZATIONS (ADDED AFTER ORIGINAL)
   * ==========================
   * - 2 Web Workers (prefetch + seek)
   * - Adaptive prefetch 8-12 MB
   * - Dynamic range fetcher + smart retry
   * - 100 ms seek stabilizer override (non-intrusive)
   * - Network speed estimator + background prefetch
   * - MSE scaffold for MP4 (best-effort)
   ************************************************************************/

  // ---------- small helpers ----------
  function bytesToMB(n){ return (n/1048576).toFixed(2); }

  // -------------------------
  // Network Speed Estimator
  // -------------------------
  const net = {
    lastRTT: 0,
    kbpsEstimate: null,
    async estimate(src) {
      try {
        const t0 = performance.now();
        const controller = new AbortController();
        setTimeout(()=>controller.abort(), 4000);
        // fetch a small chunk (64 KB)
        const res = await fetch(src, { headers: { Range: 'bytes=0-65535' }, signal: controller.signal });
        const t1 = performance.now();
        if (!res.ok) return null;
        const len = +(res.headers.get('Content-Length') || 65536);
        const ms = Math.max(1, t1 - t0);
        this.kbpsEstimate = (len * 8) / ms; // kb per ms
        // convert to kbps ~ (bits/ms -> kbps)
        this.kbpsEstimate = this.kbpsEstimate; // keep as bits/ms for relative use
        this.lastRTT = ms;
        console.log(`🌐 Speed estimate: ${bytesToMB(len)} MB chunk in ${Math.round(ms)} ms`);
        return this.kbpsEstimate;
      } catch (e) {
        return null;
      }
    }
  };

  // -------------------------
  // Two Web Workers (prefetch + seek)
  // -------------------------
  const workerCode = `
    self.onmessage = async (e) => {
      const { id, task, src, range, timeout } = e.data;
      if (!src || !range) { self.postMessage({ id, ok:false, task, error:'no-src-or-range' }); return; }
      try {
        const controller = new AbortController();
        const to = setTimeout(()=>controller.abort(), timeout || 6000);
        const r = await fetch(src, { headers: { Range: range }, signal: controller.signal, cache:'no-store' });
        clearTimeout(to);
        if (!r.ok) { self.postMessage({ id, ok:false, task, status:r.status }); return; }
        // minimal read to let connection open; we don't transfer body to main thread (memory)
        const blob = await r.blob();
        // optionally we could postMessage small metadata back
        self.postMessage({ id, ok:true, task, range, size: blob.size });
      } catch (err) {
        self.postMessage({ id, ok:false, task, error: String(err) });
      }
    };
  `;
  const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
  const workerURL = URL.createObjectURL(workerBlob);
  const prefetchWorker = new Worker(workerURL);
  const seekWorker = new Worker(workerURL);

  prefetchWorker.onmessage = (e) => {
    // console.log('PREFETCH-WORKER', e.data);
  };
  seekWorker.onmessage = (e) => {
    // console.log('SEEK-WORKER', e.data);
  };

  // -------------------------
  // Adaptive prefetch controller
  // -------------------------
  const adaptive = {
    minMB: 8,
    maxMB: 12,
    getChunk(currentTime, src, preferLarger=false){
      // dynamic chunk selection using (optional) speed estimate + preferLarger for long files
      const est = net.kbpsEstimate;
      const sizeMB = preferLarger ? this.maxMB : this.minMB;
      // if we have estimate and it's fast, bump to maxMB
      const chosenMB = (est && est > 0.03) ? this.maxMB : sizeMB; // heuristic
      const bitrate = 1.2 * 1024 * 1024; // bytes per second estimate
      const start = Math.max(0, Math.floor(currentTime * bitrate));
      const chunk = Math.floor(chosenMB * 1024 * 1024);
      return { start, end: start + chunk - 1, chunkBytes: chunk };
    }
  };

  // -------------------------
  // Smart retry wrapper for fetch ranges
  // -------------------------
  async function smartFetchRange(src, range, attempts = 2, timeout = 6000) {
    for (let i=0;i<attempts;i++){
      try {
        const controller = new AbortController();
        setTimeout(()=>controller.abort(), timeout);
        const res = await fetch(src, { headers: { Range: range }, signal: controller.signal, cache:'no-store' });
        if (res.ok) return res;
      } catch (e) {
        // retry
      }
      await new Promise(r=>setTimeout(r, 200)); // small backoff
    }
    throw new Error('range-fetch-failed');
  }

  // -------------------------
  // 100 ms seek stabilizer (non-intrusive)
  // -------------------------
  // We already have original 120ms ; override non-intrusively with 100ms where helpful
  let advSeekTimer;
  videoEl.addEventListener('seeking', () => {
    // prevent interfering with original flow: run micro-stabilizer
    clearTimeout(advSeekTimer);
    advSeekTimer = setTimeout(() => {
      if (videoEl.readyState < 3) {
        // pre-warm a small chunk around current time using seekWorker
        try {
          const src = videoEl.currentSrc || videoEl.src;
          if (!src) return;
          // compute small chunk (4 MB) around currentTime
          const bitrate = 1.2 * 1024 * 1024;
          const start = Math.max(0, Math.floor(videoEl.currentTime * bitrate));
          const end = start + (4 * 1024 * 1024) - 1;
          seekWorker.postMessage({ id:Date.now(), task:'prefetch', src, range:`bytes=${start}-${end}`, timeout:4000 });
        } catch(e){}
      }
    }, 100); // 100ms stabilizer
  });

  // -------------------------
  // Background prefetch loop (every 1s send small hints to worker)
  // -------------------------
  let backgroundPrefetchInterval = null;
  function startBackgroundPrefetch() {
    if (backgroundPrefetchInterval) return;
    backgroundPrefetchInterval = setInterval(async () => {
      try {
        const src = videoEl.currentSrc || videoEl.src;
        if (!src) return;
        // estimate network occasionally
        await net.estimate(src).catch(()=>{});
        // post small prefetch ranges near currentTime + lookahead
        const lookahead = Math.max(10, Math.floor(videoEl.currentTime + 8)); // seconds
        const { start, end, chunkBytes } = adaptive.getChunk(lookahead, src, false);
        prefetchWorker.postMessage({ id:Date.now(), task:'prefetch', src, range:`bytes=${start}-${end}`, timeout:5000 });
      } catch(e){}
    }, 1000); // every 1s
  }
  function stopBackgroundPrefetch(){
    if (backgroundPrefetchInterval) {
      clearInterval(backgroundPrefetchInterval);
      backgroundPrefetchInterval = null;
    }
  }
  // start automatically
  startBackgroundPrefetch();

  // -------------------------
  // Initial speed estimate + prefetch via worker
  // -------------------------
  (async function initAdaptive() {
    try {
      const src = videoEl.currentSrc || videoEl.src;
      if (!src) return;
      await net.estimate(src);
      // initial prefetch using prefetchWorker (8-12MB)
      const { start, end } = adaptive.getChunk(0, src, false);
      prefetchWorker.postMessage({ id:Date.now(), task:'prefetch', src, range:`bytes=${start}-${end}`, timeout:5000 });
    } catch(e){}
  })();

  // -------------------------
  // MSE scaffold (best-effort) for MP4 fragments
  // -------------------------
  // NOTE: This is best-effort: works when server supports byte-range and mp4 fragments.
  let msSupported = !!window.MediaSource;
  let mseController = { enabled:false, mediaSource:null, sourceBuffer:null, appendQueue:[] };

  async function tryInitMSE() {
    try {
      const src = videoEl.currentSrc || videoEl.src;
      if (!src) return;
      if (!msSupported) return;
      // Only try MSE for .mp4 or when content-type suggests mp4
      if (!src.endsWith('.mp4')) return;

      // Use a safe default codec string; actual success depends on file codec
      const mime = 'video/mp4; codecs="avc1.42E01E,mp4a.40.2"';
      if (!MediaSource.isTypeSupported(mime)) return;

      const ms = new MediaSource();
      mseController.mediaSource = ms;
      videoEl.src = URL.createObjectURL(ms);
      ms.addEventListener('sourceopen', async () => {
        try {
          const sb = ms.addSourceBuffer(mime);
          mseController.sourceBuffer = sb;
          mseController.enabled = true;

          // fetch initial small chunk and append
          const res = await smartFetchRange(src, 'bytes=0-1258291', 2, 6000).catch(()=>null); // ~1.2MB
          if (!res) return;
          const ab = await res.arrayBuffer();
          // append in small chunks if updating
          const appendChunk = () => {
            if (!mseController.sourceBuffer || mseController.sourceBuffer.updating) {
              setTimeout(appendChunk, 50);
              return;
            }
            try {
              mseController.sourceBuffer.appendBuffer(ab);
              console.log('MSE: appended initial chunk');
            } catch (err) {
              console.log('MSE append error', err);
            }
          };
          appendChunk();
        } catch (err) {
          console.log('MSE open error', err);
        }
      });
    } catch (e) {
      console.log('MSE init skipped', e);
    }
  }
  // attempt MSE init but do not force it (best-effort)
  tryInitMSE();

  // -------------------------
  // Clean-up on unload
  // -------------------------
  window.addEventListener('beforeunload', () => {
    prefetchWorker.terminate();
    seekWorker.terminate();
    stopBackgroundPrefetch();
    if (mseController.mediaSource) {
      try { mseController.mediaSource.endOfStream(); } catch(e){}
    }
  });

  // -------------------------
  // Optional: re-seek cache (simple in-memory cache stub)
  // -------------------------
  const blobCache = new Map(); // key: startByte, value: Blob
  // Workers currently fetch but we do not transfer blobs from worker (would be heavy).
  // This stub kept for future: if you want main-thread caching, worker can postMessage with transferable.
  // For now we rely on workers to warm server connection (reduce latency).

  /************************************************************************
   * End of advanced block
   ************************************************************************/

  // done
  console.log('✅ Player + advanced optimizations initialized');
});
</script>
<!-- Footer -->
<footer>
    <p>
        This website only provides a service to play videos online without downloading. It does not offer storage or dissemination functions. You can report videos that contain copyright issues, explicit content, 18+, violence, etc. 
        <a href="https://telegram.me/FilmymodOwner_Bot">Report</a>
    </p>
    <p><b>&copy; Copyright 2025<br>All Rights Reserved</b></p>
</footer>

</body>
</html>
























